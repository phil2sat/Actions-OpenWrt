name: build bpi-r4-std image

on:
  repository_dispatch:
  workflow_dispatch:
    inputs:
      ssh:
        description: 'SSH connection to Actions'
        required: true
        default: 'false'
        type: choice
        options:
        - true
        - false
      version:
        description: 'OpenWrt version'
        required: true
        default: 'snapshot'
        type: string

env:
  REPO_URL: https://git.openwrt.org/openwrt/openwrt.git
  REPO_BRANCH: master # Wird für den initialen Klon verwendet, kann später durch Tag/Version überschrieben werden
  # BUILD_ROOT wird dynamisch in einem späteren Schritt gesetzt, um sicherzustellen, dass es verfügbar ist
  # CUSTOM_SCRIPTS_PATH: ${{ github.workspace }} # Pfad zu den benutzerdefinierten Skripten
  TZ: Europe/Berlin
  DEVICE_NAME: unknown
  FILE_DATE: unknown
  FIRMWARE_PATH: unknown # Wird später gesetzt
  SHA_SUM_FILE: unknown   # Wird später gesetzt

jobs:
  build:
    runs-on: ubuntu-24.04
    container:
      image: openwrt/sdk:latest
      options: --user root --workdir /github/workspace --privileged
    env:
      FORCE_UNSAFE_CONFIGURE: "1"
      # CCACHE_DIR wird hier global gesetzt und von ccache-action sowie dem Build-Prozess verwendet
      CCACHE_DIR: ${{ github.workspace }}/ccache

    steps:
    - name: Checkout Workflow Repository
      uses: actions/checkout@v4
      # Die benutzerdefinierten Skripte (custom-*.sh) werden hier ausgecheckt.

    - name: Prepare Environment
      run: |
        echo "BUILD_ROOT=${{ github.workspace }}/openwrt" >> $GITHUB_ENV
        mkdir -p ${{ env.CCACHE_DIR }}
        mkdir -p ${{ github.workspace }}/openwrt # Stellt sicher, dass BUILD_ROOT existiert

    - name: Setup ccache
      uses: hendrikmuhs/ccache-action@v1.2 # Eine spezifische Version der Action verwenden
      with:
        key: openwrt-ccache-${{ github.event.inputs.version }}-${{ github.ref_name }}
        restore-keys: |
          openwrt-ccache-${{ github.event.inputs.version }}-
          openwrt-ccache-
        max-size: 2G # ccache-Größe erhöht, ggf. weiter anpassen (z.B. 5G)
        # ccache-path ist nicht nötig, da CCACHE_DIR als Umgebungsvariable gesetzt ist

    - name: Download OpenWrt sources
      run: |
        # Flacher Klon für Geschwindigkeit, falls nicht die volle Historie benötigt wird
        git clone --depth 1 --branch $REPO_BRANCH $REPO_URL ${{ env.BUILD_ROOT }}

    - name: Auto select stable revision
      id: autoselect
      if: github.event.inputs.version == 'stable' # Vereinfachte Bedingung für workflow_dispatch
      working-directory: ${{ env.BUILD_ROOT }}
      run: |
        git fetch --tags --unshallow # Tags holen und flachen Klon erweitern, falls nötig
        STABLE_TAG=$(git tag --sort=-creatordate | head -n1)
        git checkout $STABLE_TAG
        echo "Ausgewählte stabile Version: $STABLE_TAG"
        echo "status=success" >> $GITHUB_OUTPUT

    - name: Manual select version
      id: manualselect
      if: github.event.inputs.version != null && github.event.inputs.version != 'snapshot' && github.event.inputs.version != 'stable'
      working-directory: ${{ env.BUILD_ROOT }}
      run: |
        git fetch --tags --unshallow # Tags holen und flachen Klon erweitern, falls nötig
        git checkout ${{ github.event.inputs.version }}
        echo "Ausgewählte manuelle Version: ${{ github.event.inputs.version }}"
        echo "status=success" >> $GITHUB_OUTPUT
        
    - name: Show selected OpenWrt version
      working-directory: ${{ env.BUILD_ROOT }}
      run: |
        echo "Aktueller OpenWrt Commit/Tag: $(git rev-parse HEAD)"
        echo "Aktuelle OpenWrt Beschreibung: $(git describe --tags --always)"

    # Cache für heruntergeladene Tarballs von OpenWrt (dl-Verzeichnis)
    # Dieser Schritt kommt NACHDEM die OpenWrt-Quellen geklont und die Version ausgewählt wurde.
    - name: Cache OpenWrt dl directory
      uses: actions/cache@v4
      with:
        path: ${{ env.BUILD_ROOT }}/dl
        key: openwrt-dl-${{ github.event.inputs.version }}-${{ hashFiles(format('{0}/feeds.conf.default', env.BUILD_ROOT)) }}
        restore-keys: |
          openwrt-dl-${{ github.event.inputs.version }}-
          openwrt-dl-

    - name: Load custom configurations and update feeds
      run: |
        chmod +x ${{ github.workspace }}/custom-*.sh
        # Führe Skripte aus dem Workspace-Root aus, wo sie ausgecheckt wurden
        ${{ github.workspace }}/custom-feeds.sh
        
        cd ${{ env.BUILD_ROOT }}
        ./scripts/feeds update -a
        ./scripts/feeds install -a
        
        ${{ github.workspace }}/custom-packages.sh # Diese Skripte müssen ggf. BUILD_ROOT als Parameter erwarten oder relativ zu BUILD_ROOT arbeiten
        ${{ github.workspace }}/custom-config.sh   # z.B. cp ${{ github.workspace }}/my.config ${{ env.BUILD_ROOT }}/.config

    - name: Start SSH via tmate
      uses: rdp-studio/ssh2actions@main
      if: github.event.inputs.ssh == 'true'
      # Ggf. 'with: mode: tmate' oder andere Optionen hinzufügen

    - name: Build firmware
      id: compile
      working-directory: ${{ env.BUILD_ROOT }}
      run: |
        echo "Verwende $(nproc) Threads für die Kompilierung"
        echo "PATH: $PATH"
        echo "CCACHE_DIR: $CCACHE_DIR"
        echo "Überprüfe ccache Status vor dem Build:"
        ccache -s # ccache-Statistiken vor dem Build anzeigen

        # Sicherstellen, dass .config vorhanden und gültig ist (custom-config.sh sollte dies tun oder hier anpassen)
        # Falls custom-config.sh keine .config erstellt, hier z.B. cp my_defconfig .config
        make defconfig # Verarbeitet die .config, validiert sie und vervollständigt sie.
        
        echo "Lade Paketquellen herunter..."
        make download -j$(nproc) # Nutzt den wiederhergestellten dl-Cache
        
        echo "Starte Build-Prozess (world)..."
        # Original: make -j$(nproc) defconfig download clean world || make -j1 V=s
        # 'clean' entfernt, um ccache besser zu nutzen. 'defconfig' und 'download' bereits separat ausgeführt.
        # Das Fallback mit `make -j1 V=s` (oder `V=sc` für noch mehr Details) ist gut für die Fehlersuche.
        make -j$(nproc) world || make -j1 V=sc
        
        echo "ccache Status nach dem Build:"
        ccache -s # ccache-Statistiken nach dem Build anzeigen
        
        echo "status=success" >> $GITHUB_OUTPUT
        # DEVICE_NAME in den Workspace schreiben, um Konflikte mit BUILD_ROOT zu vermeiden
        grep '^CONFIG_TARGET.*DEVICE.*=y' .config | sed -r 's/.*DEVICE_(.*)=y/\1/' > ${{ github.workspace }}/DEVICE_NAME_TEMP
        echo "DEVICE_NAME=$(cat ${{ github.workspace }}/DEVICE_NAME_TEMP)" >> $GITHUB_ENV
        echo "FILE_DATE=$(date +"%Y%m%d%H%M")" >> $GITHUB_ENV

    - name: Upload bin directory
      uses: actions/upload-artifact@v4
      if: steps.compile.outputs.status == 'success'
      with:
        name: OpenWrt_bin_${{ env.DEVICE_NAME }}_${{ env.FILE_DATE }}
        path: ${{ env.BUILD_ROOT }}/bin

    - name: Organize files and prepare for release
      id: organize
      if: steps.compile.outputs.status == 'success'
      run: |
        # Finde das tatsächliche Firmware-Verzeichnis
        # Der folgende Befehl sucht nach einem Verzeichnis unterhalb von bin/targets/*/*, das KEIN 'packages'-Verzeichnis ist
        # oder wo 'packages' entfernt wurde.
        FIRMWARE_DIR_CANDIDATE=$(find ${{ env.BUILD_ROOT }}/bin/targets/*/* -maxdepth 0 -type d)
        echo "Kandidaten für Firmware-Verzeichnis: $FIRMWARE_DIR_CANDIDATE"
        # Annahme: Es gibt nur ein solches Verzeichnis pro Build. Ggf. anpassen.
        TARGET_FIRMWARE_DIR=$(echo "$FIRMWARE_DIR_CANDIDATE" | head -n1)

        if [ -z "$TARGET_FIRMWARE_DIR" ] || [ ! -d "$TARGET_FIRMWARE_DIR" ]; then
          echo "Error: Konnte das Ziel-Firmware-Verzeichnis nicht finden."
          exit 1
        fi
        echo "Ziel-Firmware-Verzeichnis: $TARGET_FIRMWARE_DIR"
        cd "$TARGET_FIRMWARE_DIR"
        rm -rf packages # Entferne das 'packages' Unterverzeichnis, falls vorhanden

        # Erstelle SHA256SUMS im BUILD_ROOT, um Schreibprobleme zu vermeiden
        sha256sum * > ${{ env.BUILD_ROOT }}/SHA256SUMS.txt
        { echo '### SHA256SUMS'; echo '```txt'; cat ${{ env.BUILD_ROOT }}/SHA256SUMS.txt; echo '```'; } > ${{ env.BUILD_ROOT }}/SHA256SUMS_BODY.md
        
        echo "FIRMWARE_PATH=$PWD" >> $GITHUB_ENV # PWD ist jetzt das korrekte Firmware-Verzeichnis
        echo "SHA_SUM_FILE=${{ env.BUILD_ROOT }}/SHA256SUMS_BODY.md" >> $GITHUB_ENV
        echo "status=success" >> $GITHUB_OUTPUT

    - name: Upload firmware artifact
      uses: actions/upload-artifact@v4
      if: steps.organize.outputs.status == 'success'
      with:
        name: OpenWrt_firmware_${{ env.DEVICE_NAME }}_${{ env.FILE_DATE }}
        path: ${{ env.FIRMWARE_PATH }} # Nutze den in 'organize' gesetzten Pfad

    - name: Generate release tag
      id: tag
      if: steps.organize.outputs.status == 'success' # Nur bei erfolgreichem Build einen Release Tag erstellen
      run: |
        OPENWRT_VERSION_DESC=""
        CURRENT_OPENWRT_VERSION_RAW=$(cd ${{ env.BUILD_ROOT }} && git describe --tags --always)

        if [[ "${{ github.event.inputs.version }}" == "snapshot" ]]; then
          # Für Snapshots einen kurzen Hash der OpenWrt-Version verwenden
          SHORT_HASH=$(echo "$CURRENT_OPENWRT_VERSION_RAW" | cut -d'-' -f1-2) # Nimmt Tag-gSHA oder nur SHA
          OPENWRT_VERSION_DESC="SNAPSHOT-${SHORT_HASH}"
        else
          # Für Releases den OpenWrt-Tag verwenden
          OPENWRT_VERSION_DESC=$(cd ${{ env.BUILD_ROOT }} && git describe --tags --abbrev=0)
        fi
        # Ersetze / durch _ für gültige Tag-Namen
        SANITIZED_OPENWRT_DESC=$(echo "$OPENWRT_VERSION_DESC" | tr '/' '_')
        echo "release_tag=${SANITIZED_OPENWRT_DESC}_${{ env.FILE_DATE }}" >> $GITHUB_OUTPUT
        echo "status=success" >> $GITHUB_OUTPUT

    - name: Create Release
      uses: softprops/action-gh-release@v1
      if: steps.tag.outputs.status == 'success'
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ steps.tag.outputs.release_tag }}
        files: |
          ${{ env.FIRMWARE_PATH }}/*
          ${{ env.BUILD_ROOT }}/SHA256SUMS.txt
        body_path: ${{ env.SHA_SUM_FILE }}

    - name: Cleanup old workflow runs
      if: always() # Wird immer ausgeführt, auch bei Fehlern
      uses: Mattraks/delete-workflow-runs@main
      with:
        token: ${{ secrets.GITHUB_TOKEN }} # Token explizit übergeben
        retain_days: 30
        keep_minimum_runs: 5

    - name: Remove old releases
      if: always() # Wird immer ausgeführt
      uses: dev-drprasad/delete-older-releases@v0.3.4
      with:
        keep_latest: 5
        delete_tags: true # Entfernt auch die Git-Tags der alten Releases
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
